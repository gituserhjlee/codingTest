Framework:sw의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게 일련의 협업화된 형태로 클래스들 제공   
Library: 자주 사용되는 로직을 재사용하기 편하게 정리한 코드 집합   
API: 라이브러리 사용할수 있게 소스 코드 수준에서 인터페이스 노출시킨것   
# 스프링 프레임워크 :    
IoC(Inversion of Control)-제어권이 사용자가 아니라 프레임워크에 있어서 스프링이 사용자의 코드 호출   Spring 컨테이너: 객체의 생성주기 관리.   
DI(Dependency Injection): 설정파일이나 어노테이션 이용 객체간의 의존관계 설정   
AOP(관점지향 프로그래밍): 여러 모듈에서 공통적으로 사용하는 기능 분리하여 관리   
POJO(Plain Old Java Object) : 컨테이너에 저장되는 자바 객체는 특정한 인터페이스 구현하거나 특정 클래스 상속받지 않아도 된다   
Maven: Build 및 배포를 위한 형상 관리 도구로 자바 라이브러리 의존성 자동 관리(스프링 부트에서는 Gradle 씀)   
***
# Scope   
singleton: 기본 - 하나의 객체를 공유   
prototype:컨테이너에서 객체를 가져올떄마다 새로운 객체가 생성      
@Scope(value="prototype")하면 getBean()으로 객체를 반환 받을때마다 새로운 객체 생성   
@Scope(value="prototype",proxyMode = ScopedProxyMode.TARGET_CLASS):해당객체의 메소드를 접근할때마다 새로운 객체 생성

# 파라미터 받기  
+  jsp에서 데이터 넘기고 controller에서 dto로받을때 : name속성에 있는 이름의 setter를 찾음
+  파라미터 변수로 받을때: 이름이 같아야함 
```
  @GetMapping("request2")
	public ModelAndView execute2( int age,String name) throws Exception{
		//컨트롤러 메소드 파라미터 타입- 일반 변수
		//메소드  인수 타입이 기본 자료형인 경우  넘어온 값이 없으면 예외 -500 일반변수는 넘어온 값이 없으면 터지지만 Model을 쓰면 안터짐 
      
 ```   
 ```
 @GetMapping("request3")
	public String execute3(User dto, Model model) throws Exception{
		//컨트롤러 파라미터 타입- Model:포워딩하는 뷰에 넘길 데이터
		model.addAttribute("msg", "컨트롤러 파라미터-모델 객체(dto)");
		model.addAttribute("dto",dto);
		
		return "user2/result2";
	}
  ```
# ModelAndView 사용 예   
```
ModelAndView mav=new ModelAndView("user2/result");
mav.addObject("msg","컨트롤러 메소드 파라미터 타입- 일반 변수");
mav.addObject("result",m);
return mav;
``` 
+ ModelAndView에 .addObject를 하는것은 request에 setAttribute하는 것과 같음 
+ .setvieName하는 것은 jsp이름을 주는것

# Annotation 및 기타 정보 정리   
@Configuration :스프링 환경설정 파일   
+ @Service 안 붙이고 자바 configuration파일에서 @Bean 을 통해서 객체를 생성할수도 있다. 
+ ```
   @Bean //빈의 이름은 기본적으로는 메소드 명 
	public UserService userServiceDevice() {
		return new UserServiceImpl();
	}
	@Bean(name="user2.user",initMethod="init",destroyMethod = "destroy")
	public User userDevice() {
		return new User();
	}
   ```

@ComponentScan(basePackages = {"com.config.user1"}):xml에서 component scan 하는걸 자바에선 이렇게 표현 
+ AbstractApplicationContext context=new AnnotationConfigApplicationContext(SpringConfig.class);   

### @RequestMapping:들어올 주소를 매핑 (옛날방식임)   
+ getmapping,postmapping 같은  주소매핑 역할인데 스프링 4 이상이어야지 get,postmapping 쓸수있어서 그 전껀 주소 설정시 requestmapping쓰기   
``` 
   @RequestMapping(value="/demo2/calc",method=RequestMethod.GET)
```  
+ class위에 @RequestMapping("/user1/*") 쓰고 각 메소드 위에 @RequestMapping(value="main", method=RequestMethod.GET) 이런식으로 *에 들어갈거를 value로 주는 식도 가능 
+ requestmapping의 리턴 자료형은 String , ModelAndView, void ,map,model등이 있음
+ void 리턴타입의 뷰 이름은 url이 "user1/info"이면 뷰 이름도 "user1/info"이다.
+  jsp안주고 직접 response의 getWriter해서 바디에 바로 print해주는 것도 가능 (PrintWriter out->out.print("html내용"))
+  map의 경우
   ```
   @GetMapping("info2")
	   public Map<String, Object> execute2() throws Exception{
	   	//Map을 리턴하는 경우 url이 "/user1/info2" 이면 뷰이름은 "user1/info2"이다.
	   	Map<String, Object> model=new HashMap<String, Object>();
	   	model.put("msg", "Map인터페이스를 리턴타입으로 포워딩 jsp에 전달");
	   	return model;			
	   }
   ```   
+ model의 경우   
   ```
   @GetMapping("info3")
	   public Model execute3() throws Exception{
	   	//Model을 리턴하는 경우 url이 "/user1/info3" 이면 뷰이름은 "user1/info3"이다.
	   	Model model=new ExtendedModelMap();
	   	model.addAttribute("msg","Model 인터페이스를 리턴타입으로 포워딩 jsp에 전달");
	   	return model;
	   }
   ```
 
controller:주소들의 묶음    
@RestController:컨트롤러로 활용할거라는 뜻       
@GetMapping:메소드 지정 안하고 주소만 지정하면됨    
@RequestParam: 파라미터로 값을 넘겨줌 . param은 String만 허용 .넘겨줄때 정수면 String.valudOf로 param넘겨주기 .   
반환형이 객체다=json형태로 리턴한다   
@RequestBody:Post에서 body에 값을 매칭시킨다는 의미    
Rest API:Get, post, put/patch, delete.스네이크케이스로 씀   
롬복:@Data를 통해 생성자와 겟터 셋터를 자동으로 만들어줌    
자바 코드는 카멜케이스 디비는 스네이크케이스   
repository:쿼리문 없이 CRUD. databse에 접근하기 위해서 생성함.JpaRepository를 상속. 어떤 레파지토린지 쓰고 키의 타입 쓰기 , @repository라고 안써도 됨.    
@Autowired:의존성 주입. 스프링이 객체를 관리 . new해서 객체를 만들 필요가 없음 . DI의 핵심은 싱글톤   
@Qualifier:autowired랑 같이 쓰고 의존성 주입하려는 bean의 이름을 지정해줄때 쓴다.    
n:1같은 참조를 상호참조하고 있으면 tostring exclude해주기     
@Service:@Component 의 구체적인 애노테이션으로 로직을 담당하는 클래스의 빈 등록   
eager:1대1에서만 사용 추천. 느려짐   
Lazy: 1대n, n대n같은 경우 추천    
쿼리메소드는 repository에 작성   
   
fetch타입은 onetomany쪽에서만 쓰기.     
@EnableJpaAuditing:jpa에 대한 감시를 활성화    
service패키지:데이터를 만들고 수정하는 일들    
service를 controller와 연결하기(Autowired를 이용)    
@Slf4j:로그를 남기는 시스템.    
map:다른 return형태로 바꾸는 것.새로운 오브젝트를 리턴    
enum:오타가 있을수있는 형태는 enum으로 관리하기    
@Pathvariable:url경로에 변수를 넣어줌    
@PostConstruct:객체의 초기화 부분.    
추상클래스:여러 클래스간에 비슷한 필드와 메서드를 공통적으로 추출해 만든 클래스 . 객체 생성은 안되고 실체 클래스와 상속관계임       
@Component:autowired를 받으려면 필요함.객체생성(xml에서 bean생성 안해도 되게). 괄호치고 빈의 이름지정 가능함 , controller service 같은 애들의 아버지임 . component는 거의 안쓰고 그 자식들을 주로 쓴다. XML에 일일이 빈 등록 안하고 자동 빈 등록    

@PostConstruct: 생성자 호출 후 바로 다음 실행.   
@PreDestroy: 컨테이너에서 빈 제거 전 사용   
sout:인텔리제이에서 프린트문 간략히.   
mockmvcTest:controller테스트임 test api같은?. perform은 예외를 넘겨야함    
@springbootTest:테스크클래스에 붙이기    
@RequiredArgsConstructor+@NonNull로 꼭 입력해야하는값 지정.자동으로 생성자 만들어짐 .선언된 모든 final필드가 포함된 생성자를 생성    
juit5에서는 public 생략하고 void 이름 이런식으로 사용     
optional로 선언해야하는 경우엔 그냥 뒤에 .get()써도 됨.    
@RunWith(SpringRunner.class)는 테스트 진행시 스프링 부트 테스트와 junit사이의 연결자 역할을 함.junit4에서 사용함     
엔터티 클래스에서는 Setter 절대 만들지 말기.    
@Transactional은 서비스 단에서 씀   
@Autowired는 bean주입을 위해서 쓰는 방식인데 사실 이 방식은 권장되지 않고 @RequiredArgsConstructor로 final이 선언된 모든 필드 생성자를 만들어서 bean객체를 받도록 하면 똑같은 효과이다.   
TestRestTemplate:controller테스트할때 mock test같은건데 실제 서블릿 컨테이너를 실행한다.   
ResponseEntity:http상태코드제어+결과데이터를 body에 담아 return       
HttpEntity란 Http프로토콜을 이용하는 통신의 header와 body관련 정보를 저장.이를 상속받은게 RequestEntity랑 ResponseEntity임    
@Resource: 이름으로 의존관계 설정. deprecated돼서 잘 안씀 . autowired쓰고 qualifier로 이름 지정해주는거랑resource(name=)하고 쓰는거랑 같음   
# 처음 세팅   
+ spring legacy project에서 spring mvc. property에서 maven및 facets에서 각각 3.1 1.8로 변경 
+ 패키지 이름중 가장 마지막 이름이 contextpath가 됨 ex.localhost:9090/app.
+ 맨처음 준 패키지 이름 ex.com.sp.app은 항상 꼭 패키지명에 포함되어야함 


